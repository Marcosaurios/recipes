<script context="module">
export async function load({ page, fetch }) {
  // TODO add loaded content
  // request it from this load function, fetching the JSON file generated by github
  const res = await fetch(`index.json`);
  console.log(res.status);
  console.log(`/content/recipes.json`);

  if (res.ok) {
    return {
      props: {
        page: await res.json(),
      },
    };
  }

  return {
    status: res.status,
    error: new Error(`Could not load ${"content/recipes"}`),
  };
  // TODO load routes/[slug].svelte
  // a PAGE with dynamic params (we won´t know which ones will be, but for example if they are
  // of the shape of /blog/[slug].svelte, we will know that they will be blog posts)

  // TODO See what routes/[slug].json.js does?? ---->>>> ONLY FOR backend things, SSG not needed
  // this is called an ENDPOINT in Svelte world, and returns an http response {status, headers, body}

  // Idea:
  // We will create each json file neded statically from the github importing script --> content/ || place json in each corresponding route, so from the same file you will be reading like ./whatever.json

  // When requesting for each category/tag, will look for the concrete json || get the whole json and filter

  // TODO i think we can query github with each different tag to get dynamic pages loaded instead loading the whole json

  // TODO when we have everything wired, lets try to load every content into an store in the first app boot. From there, the load request of each part of the app will be requesting to this page store created
}
</script>

<script lang="ts">
import type { Recipe } from "src/_types/Recipe";
export let page: Array<Recipe>;
</script>

<h1>Welcome to SvelteKit {page}</h1>

{#each page as p}
  <a href="{p.slug}">{p.title}</a>
{/each}
<p>
  Visit <a href="https://kit.svelte.dev">kit.svelte.dev</a> to read the documentation∫
</p>
